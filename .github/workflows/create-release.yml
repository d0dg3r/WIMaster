name: Create Release with Zip

on:
  push:
    tags:
      - 'v*.*.*'  # Triggers on version tags like v1.0.0
  workflow_dispatch:  # Allows manual trigger

permissions:
  contents: write  # Required for creating releases
  actions: read    # Required for downloading artifacts

jobs:
  build-setup-exe:
    runs-on: windows-2022  # Specify Windows Server 2022 explicitly
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup .NET Framework
      uses: microsoft/setup-msbuild@v1.1
      with:
        vs-version: latest
    
    - name: Find and setup C# compiler
      run: |
        Write-Host "üîç Searching for C# compiler..."
        
        # M√∂gliche Compiler-Pfade in Windows-GitHub-Runnern
        $PossiblePaths = @(
          "${env:ProgramFiles}\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\Roslyn\csc.exe",
          "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\Enterprise\MSBuild\Current\Bin\Roslyn\csc.exe",
          "${env:ProgramFiles}\dotnet\sdk\*\Roslyn\bincore\csc.dll",
          "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\BuildTools\MSBuild\Current\Bin\Roslyn\csc.exe",
          "${env:ProgramFiles}\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Roslyn\csc.exe"
        )
        
        # Windows SDK Pfade
        $WindowsKitsPaths = Get-ChildItem "${env:ProgramFiles(x86)}\Windows Kits\NETFXSDK\*\bin\NETFX*\x64\csc.exe" -ErrorAction SilentlyContinue
        if ($WindowsKitsPaths) {
          $PossiblePaths += $WindowsKitsPaths.FullName
        }
        
        # .NET Framework Compiler im Windows SDK
        $NetFxPaths = Get-ChildItem "${env:ProgramFiles(x86)}\Microsoft SDKs\Windows\*\bin\NETFX*\x64\csc.exe" -ErrorAction SilentlyContinue
        if ($NetFxPaths) {
          $PossiblePaths += $NetFxPaths.FullName
        }
        
        $CscPath = $null
        foreach ($Path in $PossiblePaths) {
          $ResolvedPaths = Resolve-Path $Path -ErrorAction SilentlyContinue
          if ($ResolvedPaths) {
            $CscPath = $ResolvedPaths[0].Path
            Write-Host "‚úÖ Found C# compiler: $CscPath"
            break
          }
        }
        
        # Always prefer .NET CLI if available (more reliable in GitHub Actions)
        if (Get-Command dotnet -ErrorAction SilentlyContinue) {
          Write-Host "‚úÖ .NET CLI available - using as primary compiler"
          echo "USE_DOTNET_CLI=true" >> $env:GITHUB_ENV
        } elseif (-not $CscPath) {
          Write-Host "‚ùå C# compiler not found in standard locations"
          throw "No C# compiler found and .NET CLI not available"
        } else {
          $CscDir = Split-Path $CscPath -Parent
          $env:PATH = "$CscDir;$env:PATH"
          Write-Host "üîß Added to PATH: $CscDir"
          Write-Host "üîß Full compiler path: $CscPath"
          
          # Store full path for later use in GitHub Actions
          echo "CSC_FULL_PATH=$CscPath" >> $env:GITHUB_ENV
        }
      shell: pwsh
    
    - name: Build Setup.exe
      run: |
        # Icon parameter if available
        $IconParam = ""
        if (Test-Path "WIMaster_Ico.ico") {
          $IconParam = '/win32icon:"WIMaster_Ico.ico"'
          Write-Host "‚úÖ Using icon: WIMaster_Ico.ico"
        }
        
        Write-Host "üî® Compiling Setup.exe for release..."
        
        if ($env:USE_DOTNET_CLI -eq "true") {
          Write-Host "Using .NET CLI for compilation..."
          
          # Create temporary csproj file for .NET CLI
          $CsprojLines = @(
            '<Project Sdk="Microsoft.NET.Sdk">',
            '  <PropertyGroup>',
            '    <OutputType>WinExe</OutputType>',
            '    <TargetFramework>net48</TargetFramework>',
            '    <UseWindowsForms>true</UseWindowsForms>',
            '    <AssemblyName>Setup</AssemblyName>',
            '    <NoWarn>MSB3245</NoWarn>',
            '  </PropertyGroup>',
            '  <ItemGroup>',
            '    <PackageReference Include="Microsoft.Win32.Registry" Version="5.0.0" />',
            '  </ItemGroup>',
            '  <ItemGroup>',
            '    <Compile Include="build-tools/WIMaster-Setup.cs" />',
            '  </ItemGroup>',
            '</Project>'
          )
          
          $CsprojLines | Out-File -FilePath "TempSetup.csproj" -Encoding UTF8
          
          dotnet build TempSetup.csproj -c Release -o .
          Remove-Item "TempSetup.csproj" -Force
          
        } else {
          # Use traditional csc.exe with full .NET Framework references
          
          # Find .NET Framework reference assemblies
          $NetFxPath = "${env:ProgramFiles(x86)}\Reference Assemblies\Microsoft\Framework\.NETFramework"
          
          Write-Host "üîç Searching for .NET Framework in: $NetFxPath"
          
          if (Test-Path $NetFxPath) {
            $AvailableFrameworks = Get-ChildItem $NetFxPath | Where-Object {$_.Name -match "^v4\."} | Sort-Object Name -Descending
            Write-Host "üìã Available frameworks: $($AvailableFrameworks.Name -join ', ')"
            
            $LatestFramework = $AvailableFrameworks | Select-Object -First 1
            $FrameworkPath = $LatestFramework.FullName
            
            Write-Host "üìö Using .NET Framework: $($LatestFramework.Name)"
            Write-Host "üìÇ Framework path: $FrameworkPath"
            
            # Verify System.Windows.Forms.dll exists
            $WinFormsPath = "$FrameworkPath\System.Windows.Forms.dll"
            if (-not (Test-Path $WinFormsPath)) {
              Write-Host "‚ùå System.Windows.Forms.dll not found at: $WinFormsPath"
              throw "Required .NET Framework assembly not found"
            } else {
              Write-Host "‚úÖ Found System.Windows.Forms.dll"
            }
          } else {
            Write-Host "‚ùå .NET Framework Reference Assemblies not found"
            throw ".NET Framework Reference Assemblies directory not found"
          }
          
          # Find Microsoft.Win32.Registry.dll location
          $RegistryDll = $null
          $PossibleRegistryPaths = @(
            "$FrameworkPath\Facades\Microsoft.Win32.Registry.dll",
            "$FrameworkPath\Microsoft.Win32.Registry.dll",
            "${env:ProgramFiles}\dotnet\shared\Microsoft.NETCore.App\*\Microsoft.Win32.Registry.dll"
          )
          
          foreach ($Path in $PossibleRegistryPaths) {
            $ResolvedPaths = Resolve-Path $Path -ErrorAction SilentlyContinue
            if ($ResolvedPaths) {
              $RegistryDll = $ResolvedPaths[0].Path
              Write-Host "üì¶ Found Registry DLL: $RegistryDll"
              break
            }
          }
          
          if (-not $RegistryDll) {
            Write-Host "‚ö†Ô∏è  Microsoft.Win32.Registry.dll not found, compiling without it"
            $Args = @(
              "/target:winexe",
              "/platform:anycpu", 
              "/optimize+",
              "/reference:$FrameworkPath\System.Windows.Forms.dll",
              "/out:Setup.exe",
              "build-tools/WIMaster-Setup.cs"
            )
          } else {
            $Args = @(
              "/target:winexe",
              "/platform:anycpu", 
              "/optimize+",
              "/reference:$FrameworkPath\System.Windows.Forms.dll",
              "/reference:$RegistryDll",
              "/out:Setup.exe",
              "build-tools/WIMaster-Setup.cs"
            )
          }
          
          if ($IconParam) {
            $Args = @($IconParam) + $Args
          }
          
          # Use full path if available, otherwise try csc in PATH
          $CscCommand = if ($env:CSC_FULL_PATH) { $env:CSC_FULL_PATH } else { "csc" }
          Write-Host "Command: $CscCommand $($Args -join ' ')"
          
          & $CscCommand @Args
        }
        
        if ($LASTEXITCODE -eq 0) {
          Write-Host "‚úÖ Setup.exe successfully compiled!"
          $FileInfo = Get-Item "Setup.exe"
          Write-Host "üìÅ File size: $($FileInfo.Length) bytes"
        } else {
          Write-Error "‚ùå Compilation failed"
          exit 1
        }
      shell: pwsh
      
    - name: Upload Setup.exe artifact
      uses: actions/upload-artifact@v4
      with:
        name: setup-exe
        path: Setup.exe
        retention-days: 1
        compression-level: 6
        if-no-files-found: error

  create-release:
    runs-on: ubuntu-latest
    needs: build-setup-exe
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download Setup.exe
      uses: actions/download-artifact@v4
      with:
        name: setup-exe
        path: .
      continue-on-error: false
      
    - name: Wait for artifact availability
      run: |
        $maxRetries = 10
        $retryCount = 0
        
        while (-not (Test-Path "Setup.exe") -and $retryCount -lt $maxRetries) {
          Write-Host "‚è≥ Waiting for Setup.exe artifact... (Attempt $($retryCount + 1)/$maxRetries)"
          Start-Sleep -Seconds 5
          $retryCount++
        }
        
        if (-not (Test-Path "Setup.exe")) {
          Write-Host "‚ùå Setup.exe artifact not found after $maxRetries retries"
          exit 1
        }
        
        Write-Host "‚úÖ Setup.exe artifact found"
      shell: pwsh
      
    - name: Verify Setup.exe
      run: |
        if [ -f "Setup.exe" ]; then
          echo "‚úÖ Setup.exe downloaded successfully"
          ls -la Setup.exe
        else
          echo "‚ùå Setup.exe not found!"
          exit 1
        fi
      
    - name: Create release zip
      run: |
        # Create a temporary directory for the release files
        mkdir -p release-temp
        
        # Copy all files except .git, .github, and other unnecessary files
        rsync -av --exclude='.git' \
                  --exclude='.github' \
                  --exclude='*.log' \
                  --exclude='*.tmp' \
                  --exclude='.DS_Store' \
                  --exclude='Thumbs.db' \
                  ./ release-temp/
        
        # Create the zip file
        cd release-temp
        zip -r ../WIMaster-release.zip .
        cd ..
        
        # Verify zip was created
        ls -la WIMaster-release.zip
    
    - name: Get tag name
      id: tag
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "tag_name=manual-$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT
        else
          echo "tag_name=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        fi
    
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.tag.outputs.tag_name }}
        name: WIMaster ${{ steps.tag.outputs.tag_name }}
        body: |
          ## WIMaster Release ${{ steps.tag.outputs.tag_name }}
          
          This release contains all WIMaster files packaged for distribution with the new Setup.exe!
          
          ### What's Included:
          - **Setup.exe** - New Windows executable with automatic UAC elevation
          - All batch and PowerShell scripts
          - Configuration files and templates  
          - Documentation files
          - Utility executables
          
          ### Installation (Recommended):
          1. Download the WIMaster-release.zip file
          2. Extract to your desired location
          3. **Run Setup.exe** (automatically requests admin rights)
          
          ### Alternative Installation:
          - Run WIMaster-Setup.bat manually "as administrator"
          
          ### New Features:
          - ‚úÖ **Setup.exe** - No more manual "Run as Administrator" required
          - ‚úÖ Automatic UAC elevation
          - ‚úÖ Enhanced error handling
          - ‚úÖ System requirements validation
        files: |
          WIMaster-release.zip
        draft: false
        prerelease: false
        fail_on_unmatched_files: true
        generate_release_notes: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
